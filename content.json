{"meta":{"title":"前端笔记","subtitle":"","description":"","author":"adversity","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"操作树","slug":"操作树","date":"2022-07-27T08:13:53.385Z","updated":"2022-07-27T08:14:54.521Z","comments":true,"path":"2022/07/27/操作树/","link":"","permalink":"http://example.com/2022/07/27/%E6%93%8D%E4%BD%9C%E6%A0%91/","excerpt":"","text":"12345678910111213//数据const treeData = [ &#123; key: &#x27;0-0&#x27;, title: &#x27;0-0&#x27; &#125;, &#123; key: &#x27;0-1&#x27;, title: &#x27;0-1&#x27;, children: [ &#123; key: &#x27;0-1-0&#x27;, title: &#x27;0-1-0&#x27; &#125;, &#123; key: &#x27;0-1-1&#x27;, title: &#x27;0-1-1&#x27; &#125;, ], &#125;, &#123; key: &#x27;0-2&#x27;, title: &#x27;0-2&#x27; &#125;,] 方法一 常规方法 123456789101112131415161718const getTreeDataByKeys: (targets: any[], ids: any[]) =&gt; any = (targets: any[], ids: any[]) =&gt; &#123; let transferDataSource: any[] = []; function handleTreeData(targets: any[], ids: any[]) &#123; targets.map((vv, ii) =&gt; &#123; if (ids.includes(vv.key)) &#123; transferDataSource.push(&#123; value: vv.title, id: vv.key, &#125;); if (vv.children) &#123; handleTreeData(vv.children, ids); &#125; &#125; &#125;); &#125; handleTreeData(targets, ids); return transferDataSource;&#125;; 方法二 优化过一下写法的 12345678const getTreeDataByKeys2 = (targets: any[], ids: any[], tempData: any[] = []) =&gt; &#123; // let transferDataSource: any[] = []; targets.forEach((vv, ii) =&gt; &#123; getTreeDataByKeys2(vv.children || [], ids, tempData); ids.includes(vv.key) &amp;&amp; tempData.push(vv); &#125;); return tempData.map((v) =&gt; (&#123; value: v.title, id: v.key &#125;));&#125;; 方法三 先平铺树，再遍历 12345678910const getTreeDataByKeys3 = (trees: any[], flaten: any[] = []) =&gt; &#123; trees.forEach((tree) =&gt; &#123; flaten.push(tree); getTreeDataByKeys3(tree.children || [], flaten); &#125;); return flaten;&#125;;const handleGetNodes = (flatenTree: any[], ids: any[]) =&gt; &#123; return ids.map((v) =&gt; flatenTree.find((vv) =&gt; vv.key === v));&#125;; 方法四 在方法三的基础上再优化 123456789101112handleGetFlatenTree(trees = [],flaten = &#123;&#125;)&#123; trees.forEach (tree=&gt;&#123; falten[tree.key] = tree ; handleGetFlatenTree(tree.children,flaten); &#125;) return flaten;&#125;handleGetNodes (ids = [],flatenTree = &#123;&#125;)&#123; return ids.map(v=&gt; flatenTree[v])&#125;","categories":[],"tags":[]},{"title":"扁平数据结构转tree","slug":"扁平数据结构转tree","date":"2022-07-27T08:13:53.384Z","updated":"2022-07-27T08:15:06.281Z","comments":true,"path":"2022/07/27/扁平数据结构转tree/","link":"","permalink":"http://example.com/2022/07/27/%E6%89%81%E5%B9%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%ACtree/","excerpt":"","text":"123456789//打平的数据let arr = [ &#123;id: 1, name: &#x27;部门1&#x27;, pid: 0&#125;, &#123;id: 2, name: &#x27;部门2&#x27;, pid: 1&#125;, &#123;id: 3, name: &#x27;部门3&#x27;, pid: 1&#125;, &#123;id: 4, name: &#x27;部门4&#x27;, pid: 3&#125;, &#123;id: 5, name: &#x27;部门5&#x27;, pid: 4&#125;,] 递归方法实现 (时间复杂度为O(n^2)) 12345678910const getChildren = (data, result = [], pid = 0) =&gt; &#123; for (const item of data) &#123; if (item.pid === pid) &#123; const newItem = &#123; ...item, children: [] &#125;; result.push(newItem); getChildren(data, newItem.children, item.id); &#125; &#125; return result&#125; map 实现（时间复杂度为O(n)) 123456789101112131415161718192021222324252627function arrayToTree(items) &#123; const result = []; // 存放结果集 const itemMap = &#123;&#125;; // // 先转成map存储 for (const item of items) &#123; itemMap[item.id] = &#123; ...item, children: [] &#125; &#125; for (const item of items) &#123; const id = item.id; const pid = item.pid; const treeItem = itemMap[id]; if (pid === 0) &#123; result.push(treeItem); &#125; else &#123; if (!itemMap[pid]) &#123; itemMap[pid] = &#123; children: [], &#125; &#125; itemMap[pid].children.push(treeItem) &#125; &#125; return result;&#125; 主要思路也是先把数据转成Map去存储，之后遍历的同时借助对象的引用，直接从Map找对应的数据做存储。不同点在遍历的时候即做Map存储,有找对应关系。性能会更好。 12345678910111213141516171819202122232425262728293031323334function arrayToTree(items) &#123; const result = []; // 存放结果集 const itemMap = &#123;&#125;; // for (const item of items) &#123; const id = item.id; const pid = item.pid; if (!itemMap[id]) &#123; itemMap[id] = &#123; children: [], &#125; &#125; itemMap[id] = &#123; ...item, children: itemMap[id][&#x27;children&#x27;] &#125; const treeItem = itemMap[id]; if (pid === 0) &#123; result.push(treeItem); &#125; else &#123; if (!itemMap[pid]) &#123; itemMap[pid] = &#123; children: [], &#125; &#125; itemMap[pid].children.push(treeItem) &#125; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"正则表达式收集","slug":"正则表达式","date":"2022-07-27T08:13:53.382Z","updated":"2022-07-27T08:16:39.607Z","comments":true,"path":"2022/07/27/正则表达式/","link":"","permalink":"http://example.com/2022/07/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"[TOC] 正则表达式收集1.网址完整性匹配1^(http(s)?:\\/\\/)?(www\\.)?[\\w-]+\\.(com|net|cn)$ 2.千分位划分123const reg = /\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g return `$&#123;v&#125;`.replace(reg, &#x27;$&amp;,&#x27;)&#125; demo: 123456formatNumber = (num) =&gt; &#123; // console.log(num) let source = String(num).split(&#x27;.&#x27;); source[0] = source[0].replace(/\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g, &#x27;$&amp;,&#x27;) return source.join(&#x27;.&#x27;); &#125;","categories":[],"tags":[]},{"title":"扁平数据结构转tree","slug":"树结构下的空文件过滤","date":"2022-07-27T08:13:53.376Z","updated":"2022-07-27T08:15:28.987Z","comments":true,"path":"2022/07/27/树结构下的空文件过滤/","link":"","permalink":"http://example.com/2022/07/27/%E6%A0%91%E7%BB%93%E6%9E%84%E4%B8%8B%E7%9A%84%E7%A9%BA%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//原始数据const tree_data_1 = [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e9fa6f&quot;, &quot;groupName&quot;: &quot;工会后勤&quot;, &quot;sortNumber&quot;: 1, &quot;appList&quot;: [ &#123; &quot;id&quot;: &quot;9cab0d612097443bb94717e36bce6cc1&quot;, &quot;appName&quot;: &quot;食堂用餐&quot; &#125; ] &#125;, &#123; &quot;id&quot;: &quot;df6aec37268d4a878ed55723f09655bb&quot;, &quot;groupName&quot;: &quot;固定资产&quot;, &quot;sortNumber&quot;: 1, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e996c&quot;, &quot;groupName&quot;: &quot;总项&quot;, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;df6aec37268d4a878ed55723f0963fa&quot;, &quot;groupName&quot;: &quot;设备&quot;, &quot;appList&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e9abc&quot;, &quot;groupName&quot;: &quot;不动产&quot;, &quot;appList&quot;: [ &#123; &quot;id&quot;: &quot;b7c6d6a22aa74304acf37f4d408052c5&quot;, &quot;appName&quot;: &quot;会议室&quot; &#125;, &#123; &quot;id&quot;: &quot;f0fbba97a9c24f5ba0454e87c56e72f1&quot;, &quot;appName&quot;: &quot;办公室&quot; &#125; ] &#125; ] &#125; ] &#125;, &#123; &quot;id&quot;: &quot;df6aec37268d4a878ed55723f09655cc&quot;, &quot;groupName&quot;: &quot;健康&quot;, &quot;sortNumber&quot;: 1, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090ecccc&quot;, &quot;groupName&quot;: &quot;运动&quot;, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;df6aec37268d4a878ed55723f0cccc&quot;, &quot;groupName&quot;: &quot;走步&quot;, &quot;appList&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e9ccc&quot;, &quot;groupName&quot;: &quot;健身&quot;, &quot;appList&quot;: [] &#125; ] &#125; ] &#125;, &#123; &quot;id&quot;: &quot;aca25f2fa2974e59abb2318d1c94b0dd&quot;, &quot;groupName&quot;: &quot;出勤&quot;, &quot;sortNumber&quot;: 7, &quot;appList&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;c598d4f422e20534386a81095e53964e&quot;, &quot;groupName&quot;: &quot;审批&quot;, &quot;icon&quot;: &quot;&quot;, &quot;sortNumber&quot;: 10, &quot;appList&quot;: [] &#125; ]//所需数据const needData =const needData = [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e9fa6f&quot;, &quot;groupName&quot;: &quot;工会后勤&quot;, &quot;sortNumber&quot;: 1, &quot;appList&quot;: [ &#123; &quot;id&quot;: &quot;9cab0d612097443bb94717e36bce6cc1&quot;, &quot;appName&quot;: &quot;食堂用餐&quot; &#125; ], &quot;children&quot;: [] &#125;, &#123; &quot;id&quot;: &quot;df6aec37268d4a878ed55723f09655bb&quot;, &quot;groupName&quot;: &quot;固定资产&quot;, &quot;sortNumber&quot;: 1, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e996c&quot;, &quot;groupName&quot;: &quot;总项&quot;, &quot;appList&quot;: [], &quot;children&quot;: [ &#123; &quot;id&quot;: &quot;268604b055934ea1a05e3b7090e9abc&quot;, &quot;groupName&quot;: &quot; 不动产&quot;, &quot;appList&quot;: [ &#123; &quot;id&quot;: &quot;b7c6d6a22aa74304acf37f4d408052c5&quot;, &quot;appName&quot;: &quot;会议室&quot; &#125;, &#123; &quot;id&quot;: &quot;f0fbba97a9c24f5ba0454e87c56e72f1&quot;, &quot;appName&quot;: &quot;办公室&quot; &#125; ], &quot;children&quot;: [] &#125; ] &#125; ] &#125;] reduce 写法 1234567891011121314151617181920212223function handleFilterTree(data = []) &#123; return data.reduce((acc, cur) =&gt; &#123; let shouldRetain = false; if (cur.appList &amp;&amp; cur.appList.length &gt; 0) &#123; shouldRetain = true; &#125; const children = this.handleFilterTree(cur.children || []); if (children &amp;&amp; children.length &gt; 0) &#123; shouldRetain = true; &#125; if (shouldRetain) &#123; acc.push(&#123; ...cur, children, &#125;); &#125; return acc; &#125;, []);&#125; forEach 写法 12345678910111213141516171819function handleFilterTree1(data = []) &#123; let arr = []; data.forEach(item =&gt; &#123; let shouldRetain = false; if (item.appList &amp;&amp; item.appList.length &gt; 0) &#123; shouldRetain = true; &#125; if (item.children &amp;&amp; item.children.length) &#123; item.children = handleFilterTree(item.children) &#125; if (item.children &amp;&amp; item.children.length) &#123; shouldRetain = true; &#125; shouldRetain &amp;&amp; arr.push(item) &#125;) return arr;&#125;","categories":[],"tags":[]},{"title":"操作树","slug":"就是给一个id，去树中找出这个id并把它的所有父节点都找出来返回一个数组路径","date":"2022-07-27T08:13:53.371Z","updated":"2022-07-27T08:14:41.056Z","comments":true,"path":"2022/07/27/就是给一个id，去树中找出这个id并把它的所有父节点都找出来返回一个数组路径/","link":"","permalink":"http://example.com/2022/07/27/%E5%B0%B1%E6%98%AF%E7%BB%99%E4%B8%80%E4%B8%AAid%EF%BC%8C%E5%8E%BB%E6%A0%91%E4%B8%AD%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AAid%E5%B9%B6%E6%8A%8A%E5%AE%83%E7%9A%84%E6%89%80%E6%9C%89%E7%88%B6%E8%8A%82%E7%82%B9%E9%83%BD%E6%89%BE%E5%87%BA%E6%9D%A5%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E8%B7%AF%E5%BE%84/","excerpt":"","text":"就是给一个id，去树中找出这个id并把它的所有父节点都找出来返回一个数组路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const treeData = [ &#123; key: &#x27;0-0&#x27;, title: &#x27;0-0&#x27; &#125;, &#123; key: &#x27;0-1&#x27;, title: &#x27;0-1&#x27;, children: [ &#123; key: &#x27;0-1-0&#x27;, title: &#x27;0-1-0&#x27;, children: [ &#123; key: &#x27;0-1-0-1&#x27;, title: &#x27;0-1-0-1&#x27; &#125;, &#123; key: &#x27;0-1-0-2&#x27;, title: &#x27;0-1-0-2&#x27; &#125;, ], &#125;, &#123; key: &#x27;0-1-1&#x27;, title: &#x27;0-1-1&#x27; &#125;, ], &#125;, &#123; key: &#x27;0-2&#x27;, title: &#x27;0-2&#x27;, children: [ &#123; key: &#x27;0-2-0&#x27;, title: &#x27;0-2-0&#x27;, children: [ &#123; key: &#x27;0-2-0-1&#x27;, title: &#x27;0-2-0-1&#x27; &#125;, &#123; key: &#x27;0-2-0-2&#x27;, title: &#x27;0-2-0-2&#x27; &#125;, ], &#125;, &#123; key: &#x27;0-2-1&#x27;, title: &#x27;0-2-1&#x27; &#125;, ], &#125;,]function handleGetValuePath(id, options = [], pathValue = [], path = []) &#123; if (id === null || id === &#x27;&#x27;) &#123; return [] &#125; for (const option of options) &#123; if (option[&#x27;key&#x27;] === id) &#123; pathValue.push(...path, option); break; &#125; if (option.children &amp;&amp; option.children.length) &#123; handleGetValuePath(id, option.children, pathValue, [...path, option]) &#125; &#125; return pathValue&#125;const pathTemp = handleGetValuePath(&#x27;0-1-0-2&#x27;, treeData)console.log(&#x27;--=-==-=id搜索树&#x27;);console.log(JSON.stringify(pathTemp));","categories":[],"tags":[]},{"title":"git小知识","slug":"git小知识","date":"2022-07-27T08:03:17.982Z","updated":"2022-07-27T08:10:42.054Z","comments":true,"path":"2022/07/27/git小知识/","link":"","permalink":"http://example.com/2022/07/27/git%E5%B0%8F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1.gitignore文件问题： 在项目开发中我们都会添加.gitignore文件，比如idea中的idea目录、target目录等，但有时会发现，配置后并不生效，原因是：.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。解决方案就是把本地缓存删除（改成未track状态），然后再提交。 123git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27;","categories":[],"tags":[]},{"title":"Generator","slug":"Generator","date":"2022-07-27T08:03:17.978Z","updated":"2022-07-27T08:10:45.614Z","comments":true,"path":"2022/07/27/Generator/","link":"","permalink":"http://example.com/2022/07/27/Generator/","excerpt":"","text":"Generator yield相当于执行到当前就暂停，它的返回值是由外面的参数决定的也就是外面调next时传的参数 外面又能通过.value获得yield后面的值 通过Generator读文件 1.自己的笨办法 123456789101112131415161718192021const fs = require(&#x27;fs&#x27;)const readFileAsync = (fileName) =&gt; &#123; return new Promise((reslove, reject) =&gt; &#123; fs.readFile(fileName, &#x27;utf8&#x27;, (error, data) =&gt; &#123; if (error) return reject(error) reslove(data) &#125;) &#125;)&#125;const gen = function* () &#123; const f1 = yield readFileAsync(&#x27;./read/demo.md&#x27;) const f2 = yield readFileAsync(&#x27;./read/demo01.md&#x27;)&#125;for (let v of gen()) &#123; v.then(res=&gt;&#123; console.log(&#x27;---文件内容--&#x27;); console.log(res); &#125;)&#125; 用types读取yeild后面的Promise直接生成结果 123456789101112131415161718192021222324252627282930313233const &#123; types&#125; = require(&#x27;util&#x27;);const fs = require(&#x27;fs&#x27;);const readFileAsync = (fileName) =&gt; &#123; return new Promise((reslove, reject) =&gt; &#123; fs.readFile(fileName, (error, data) =&gt; &#123; if (error) return reject(error) reslove(data) &#125;) &#125;)&#125;const gen = function* () &#123; const f1 = yield readFileAsync(&#x27;./read/demo.md&#x27;) const f2 = yield readFileAsync(&#x27;./read/demo01.md&#x27;) console.log(&#x27;---f1--&#x27;); console.log(f1.toString());&#125;const runner = (gen, data) =&gt; &#123; const item = gen.next(data); if (!item.done) &#123; if (types.isPromise(item.value)) &#123; item.value.then((res) =&gt; runner(gen, res)); &#125; else &#123; runner(gen, item.value); &#125; &#125;&#125;;runner(gen()) 3.改一哈上面的readFileAsync方法,nodejs的Api回调里面几乎都是err作为第一个参数，然后promisify就根据这个特性把它包装成一个Promise 1234567891011121314151617181920212223242526272829303132333435363738const &#123; types, promisify &#125; = require(&#x27;util&#x27;);const fs = require(&#x27;fs&#x27;);/*const readFileAsync = (fileName) =&gt; &#123; return new Promise((reslove, reject) =&gt; &#123; fs.readFile(fileName, (error, data) =&gt; &#123; if (error) return reject(error) reslove(data) &#125;) &#125;)&#125;*/const readFileAsync = promisify(fs.readFile); //等价于上面的Promiseconst gen = function* () &#123; const f1 = yield readFileAsync(&#x27;./read/demo.md&#x27;) const f2 = yield readFileAsync(&#x27;./read/demo01.md&#x27;) console.log(&#x27;---f1--&#x27;); console.log(f1.toString());&#125;const runner = (gen, data) =&gt; &#123; const item = gen.next(data); if (!item.done) &#123; if (types.isPromise(item.value)) &#123; item.value.then((res) =&gt; runner(gen, res)); &#125; else &#123; runner(gen, item.value); &#125; &#125;&#125;;runner(gen()) 4.fs官方内置的Promise操作方法 123456789101112131415161718192021222324252627const &#123; types &#125; = require(&#x27;util&#x27;);const fs = require(&#x27;fs&#x27;);const &#123; readFile &#125; = require(&#x27;fs/promises&#x27;);const gen = function* () &#123; const f1 = yield readFile(&#x27;./read/demo.md&#x27;) console.log(f1.toString()); const f2 = yield readFile(&#x27;./read/demo01.md&#x27;) // return f2.toString()&#125;const runner = (gen, data) =&gt; &#123; const item = gen.next(data); if (!item.done) &#123; if (types.isPromise(item.value)) &#123; item.value.then((res) =&gt; runner(gen, res)); &#125; else &#123; runner(gen, item.value); &#125; &#125;&#125;;runner(gen())","categories":[],"tags":[]},{"title":"ES6常用点归纳总结","slug":"ES6常用点归纳总结","date":"2022-07-27T08:03:17.975Z","updated":"2022-07-27T08:07:52.992Z","comments":true,"path":"2022/07/27/ES6常用点归纳总结/","link":"","permalink":"http://example.com/2022/07/27/ES6%E5%B8%B8%E7%94%A8%E7%82%B9%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/","excerpt":"","text":"ES6常用点归纳总结一 数组扁平化扁平化：深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 题目：一个部门JSON数据中，属性名是部门id，属性值是个部门成员id数组集合，现在要把有部门的成员id都提取到一个数组集合中。 123456const deps = &#123; &#x27;采购部&#x27;: [1, 2, 3], &#x27;人事部&#x27;: [5, 8, 12], &#x27;行政部&#x27;: [5, 14, 79], &#x27;运输部&#x27;: [3, 64, 105],&#125; 避免使用如下代码 12345678let member = [];for (let item in deps) &#123; const value = deps[item]; if (Array.isArray(value)) &#123; member = [...member, ...value] &#125;&#125;member = [...new Set(member)] 优美代码如下： 12let member_youhua = Object.values(deps).flat(Infinity);console.log(&#x27;===优化过后的输出=====&#x27;, [...new Set(member_youhua)]); 获取对象的全部键值 Object.keys 获取对象的全部属性值 Object.values 数组的扁平化处理 flat() ,其中使用Infinity作为flat的参数，使得无需知道被扁平化的数组的维度 flat() 方法会移除数组中的空项 二、输入框非空判断 原始写法 1234if(value !== null &amp;&amp; value !== undefined &amp;&amp; value !== &#x27;&#x27;)&#123; //...&#125; 进一步优化之后的写法 12345678/***非全等null就是说是null或undefined*全等那就是null**/if(value != null &amp;&amp; value !== &#x27;&#x27;)&#123; //...&#125; 简洁写法 123if((value??&#x27;&#x27; )!== &#x27;&#x27;)&#123; //...&#125; 三、解构赋值取值在程序中非常常见，比如从对象obj中取值： 1234567const obj = &#123; a:1, b:2, c:3, d:4, e:5,&#125; 123const &#123; a,b,c,d &#125;= obj;const f = a + d;const g = c + e; 如果想要创建的变量名和对象的属性名不一致，可以这么来写： 12const &#123;a:a1&#125; = obj;console.log(a1);// 1 ES6的解构赋值虽然好用，但是要注意解构的对象不能为undefined 、null，否则会报错，故要给被解构的对象一个默认值 1const &#123;a,b,c,d,e&#125; = obj || &#123;&#125;; 四、合并数据 合并两个数组，合并两个对象。 一般写法 123456789101112const a = [1,2,3];const b = [1,5,6];const c = a.concat(b);//[1,2,3,1,5,6]const obj1 = &#123; a:1,&#125;const obj1 = &#123; b:1,&#125;const obj = Object.assign(&#123;&#125;, obj1, obj2);//&#123;a:1,b:1&#125; 注意：没有考虑去重 推荐写法 123456789101112const a = [1,2,3];const b = [1,5,6];const c = [...new Set([...a,...b])];//[1,2,3,5,6]const obj1 = &#123; a:1,&#125;const obj2 = &#123; b:1,&#125;const obj = &#123;...obj1,...obj2&#125;;//&#123;a:1,b:1&#125; 五、关于if中判断条件123456789if( type == 1 || type == 2 || type == 3 || type == 4 ||)&#123; //...&#125; 改进 12345const condition = [1,2,3,4];if( condition.includes(type) )&#123; //...&#125; 六、异步函数 异步函数很常见，经常是用 Promise 来实现 12345678910111213141516171819202122const fn1 = () =&gt;&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 300); &#125;);&#125;const fn2 = () =&gt;&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 600); &#125;);&#125;const fn = () =&gt;&#123; fn1().then(res1 =&gt;&#123; console.log(res1);// 1 fn2().then(res2 =&gt;&#123; console.log(res2) &#125;) &#125;)&#125; 改进： 123456const fn = async () =&gt;&#123; const res1 = await fn1(); const res2 = await fn2(); console.log(res1);// 1 console.log(res2);// 2&#125;","categories":[],"tags":[]},{"title":"ES6至ES8入门到进阶实战","slug":"ES6","date":"2022-07-27T08:03:17.973Z","updated":"2022-07-27T08:11:40.010Z","comments":true,"path":"2022/07/27/ES6/","link":"","permalink":"http://example.com/2022/07/27/ES6/","excerpt":"","text":"ES6至ES8入门到进阶实战 let 、 var 、const let （块级作用域） 只在声明的代码块中生效 暂时性死区（在声明变量之前我们是无法读取或者操作这个变量的。） 没有变量提升 无法重复声明 const （块级作用域） 只能保证里面的内存地址不变","categories":[],"tags":[]},{"title":"js日常积累","slug":"js日常积累","date":"2022-07-27T08:03:17.971Z","updated":"2022-07-27T08:06:59.830Z","comments":true,"path":"2022/07/27/js日常积累/","link":"","permalink":"http://example.com/2022/07/27/js%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"1.获取浏览器类型 123456789101112131415161718192021222324const getBroswer = () =&gt; &#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; if (userAgent.indexOf(&quot;Opera&quot;) &gt; -1) &#123; return &quot;Opera&quot; &#125;; //判断是否Opera浏览器 if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) &#123; return &quot;Firefox&quot;; &#125; //判断是否Firefox浏览器 if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1) &#123; return &quot;Chrome&quot;; &#125; //判断是否Chrome浏览器 if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) &#123; return &quot;Safari&quot;; &#125; //判断是否Safari浏览器 if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) &#123; return &quot;IE&quot;; &#125;; //判断是否IE浏览器 if (userAgent.indexOf(&quot;Trident&quot;) &gt; -1) &#123; return &quot;Edge&quot;; &#125; //判断是否Edge浏览器&#125;export default getBroswer; 2.关闭当前标签页","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-07-27T07:15:36.406Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/07/27/hello-world/","link":"","permalink":"http://example.com/2022/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}